--[[
	Recursive-descent parser implementation. The main routine is `Parser::parseChunk()`.
]]

local AstNode = if script then require(script.Parent.ast) else require("./ast")
local Token = if script then require(script.Parent.lex_token) else require("./lex_token")

local Parser = {}
Parser.__index = Parser

Parser.simpleTokens = {
	[Token.Kind.ReservedTrue] = AstNode.Kind.True,
	[Token.Kind.ReservedFalse] = AstNode.Kind.False,
	[Token.Kind.ReservedNil] = AstNode.Kind.Nil,
	[Token.Kind.Dot3] = AstNode.Kind.Dot3,
}

Parser.compountOpers = {
	[Token.Kind.PlusEqual] = AstNode.Kind.Add,
	[Token.Kind.MinusEqual] = AstNode.Kind.Sub,
	[Token.Kind.StarEqual] = AstNode.Kind.Mul,
	[Token.Kind.SlashEqual] = AstNode.Kind.Div,
}

Parser.unaryOpers = {
	[Token.Kind.Hashtag] = AstNode.Kind.Len,
	[Token.Kind.ReservedNot] = AstNode.Kind.Not,
	[Token.Kind.Minus] = AstNode.Kind.Neg,
}

Parser.binaryOpers = {
	[Token.Kind.Plus] = AstNode.Kind.Add,
	[Token.Kind.Minus] = AstNode.Kind.Sub,
	[Token.Kind.Star] = AstNode.Kind.Mul,
	[Token.Kind.Slash] = AstNode.Kind.Div,
	[Token.Kind.Modulo] = AstNode.Kind.Mod,
	[Token.Kind.Caret] = AstNode.Kind.Pow,
	[Token.Kind.Dot2] = AstNode.Kind.Concat,
	[Token.Kind.NotEqual] = AstNode.Kind.CompareNe,
	[Token.Kind.EqualTo] = AstNode.Kind.CompareEq,
	[Token.Kind.LessThan] = AstNode.Kind.CompareLt,
	[Token.Kind.LessEqual] = AstNode.Kind.CompareLe,
	[Token.Kind.GreaterThan] = AstNode.Kind.CompareGt,
	[Token.Kind.GreaterEqual] = AstNode.Kind.CompareGe,
	[Token.Kind.ReservedAnd] = AstNode.Kind.And,
	[Token.Kind.ReservedOr] = AstNode.Kind.Or,
}

function Parser.new(tokens, names, options, advancer)
	local self = {}
	setmetatable(self, Parser)

	local index = 0
	self._advancer = advancer or function()
		index = index + 1
		if index <= #self._tokens then
			return self._tokens[index]
		end

		return nil
	end

	self._tokens = tokens
	self._names = names or {}
	self._token = self._advancer()

	return self
end

function Parser.is(object)
	return type(object) == "table" and getmetatable(object) == Parser
end

--[[
	Creates an operator parsing routine, from a generic function.

	This is done to avoid repeating code, and will return a function that will parse the provided
	operators, and call the provided subparser to get the operands.
]]
function Parser.useGeneric(generic, subParser, ...)
	local operators = table.pack(...)

	return function(self)
		return generic(self, operators, subParser)
	end
end

--[[
	Determines whether a statement is the last statement of a block.

	This saves us time because we won't have to parse statements after it.
]]
function Parser.isLastStat(stat)
	return stat.kind == AstNode.Kind.Break or stat.Kind == AstNode.Kind.Continue or stat.kind == AstNode.Kind.Return
end

--[[
	Determins whether an expression is a valid L-value for an assignment.

	Used in both normal and compound and normal assignments.
]]
function Parser.isExprLValue(expr)
	return expr.kind == AstNode.Kind.Local
		or expr.kind == AstNode.Kind.Global
		or expr.kind == AstNode.Kind.IndexExpr
		or expr.kind == AstNode.Kind.IndexName
end

--[[
	Determines whether a statement is part of a block or not.

	Used by Parser::parseBlock to see when to stop the statement-paring loop.
]]
function Parser.isFollowingBlock(token)
	-- TODO: We might want to replace this with something like:
	-- table.find({ ... }, token.kind)
	-- (same applies for Parser::isExprLValue)
	return token.kind == Token.Kind.EndOfFile
		or token.kind == Token.Kind.ReservedElse
		or token.kind == Token.Kind.ReservedElseIf
		or token.kind == Token.Kind.ReservedEnd
		or token.kind == Token.Kind.ReservedUntil
end

function Parser:_shouldParseTypePackAnnotation()
	return self:_peek() == Token.Kind.Dot3
		or (self:_peek() == Token.Kind.Name and self:_peek(2) == Token.Kind.Dot3)
end

--[[
	Throws an error generated by the parser.

	Note that this can be overriden by the user (since it's retrieved through the `__index`
	metamethod).
]]
-- luacheck: ignore self
function Parser:_error(formatString, ...)
	error(formatString:format(...))
end

--[[
	Advances to the next token.
]]
function Parser:_advance()
	self._token = self._advancer()
end

--[[
	Accepts a token if valid, and returns nil otherwise.
]]
function Parser:_accept(tokenKind)
	local token = self._token
	if token and token.kind == tokenKind then
		self:_advance()
		return token
	end

	return nil
end

--[[
	Peeks for a token and returns it, but does not actually consume it.
]]
function Parser:_peek(tokenKind)
	local token = self._token
	if token and token.kind == tokenKind then
		return token
	end

	return nil
end

--[[
	Expects to read a certain type of token. If this token is not found, then it will throw a
	parse-error.
]]
function Parser:_expect(tokenKind, context)
	local token = self._token

	if token.kind == Token.Kind.Comment then
		-- we ignore comment
		repeat
			self:_advance()
			token = self._token
		until token.kind ~= Token.Kind.Comment
	end
	if not token or token.kind ~= tokenKind then
		if context then
			self:_error(
				"Expected Token.%s when parsing %s, got Token.%s",
				tostring(tokenKind),
				context,
				tostring(token.kind)
			)
		else
			self:_error("Expected Token.%s, got Token.%s", tostring(tokenKind), tostring(token.kind))
		end
	end

	self:_advance()
	return token
end

--[[
	Helper function to parse things separate by a delimiter token. This is used for expression
	lists, and other things like that.
]]
function Parser:_parseList(subParser, delimiter, ...)
	local values = {}

	repeat
		table.insert(values, subParser(self, ...))
	until not self:_accept(delimiter)

	return values
end

function Parser:genericBinary(tokens, subParser)
	local left = subParser(self)

	if not self._token then
		return left
	end

	while true do
		local token = nil
		for _, possibleToken in ipairs(tokens) do
			if self:_accept(possibleToken) then
				token = possibleToken
			end
		end

		if not token then
			break
		end

		local right = subParser(self)
		local nodeKind = Parser.binaryOpers[token]
		left = AstNode.new(nodeKind, left, right)
	end

	return left
end

function Parser:genericPrefix(tokens, subParser)
	local left = subParser(self)
	local stack = {}

	if not left then
		return
	end

	while true do
		local token = nil
		for _, possibleToken in ipairs(tokens) do
			if self:_accept(possibleToken) then
				token = possibleToken
			end
		end

		if not token then
			break
		end

		table.insert(stack, token)
	end

	-- We must use a numeric-for loop so that we can go backwards through the stack, starting at
	-- the top.
	for i = #stack, 1, -1 do
		local nodeKind = Parser.unaryOpers[stack[i]]
		left = AstNode.new(nodeKind, left)
	end

	return left
end

function Parser:genericPostfix(tokens, subParser)
	local left = subParser(self)

	while true do
		local token = nil
		for _, possibleToken in ipairs(tokens) do
			if self:_accept(possibleToken) then
				token = possibleToken
			end
		end

		if not token then
			break
		end

		local nodeKind = Parser.unaryOpers[token]
		left = AstNode.new(nodeKind, left)
	end

	return left
end

function Parser:parseAssertionExpr()
	local expr = self:parseSimpleExpr()

	if self:_accept(Token.Kind.DoubleColon) then
		local annotation = self:parseTypeAnnotation()
		expr = AstNode.new(AstNode.Kind.TypeAssertion, expr, annotation)
	end

	return expr
end

-- Generic operator usage.
Parser.parsePow = Parser.useGeneric(Parser.genericBinary, Parser.parseAssertionExpr, Token.Kind.Caret)
Parser.parseUnary = Parser.useGeneric(
	Parser.genericPrefix,
	Parser.parsePow,
	Token.Kind.Minus,
	Token.Kind.ReservedNot
)

Parser.parseFactor = Parser.useGeneric(Parser.genericBinary, Parser.parseUnary, Token.Kind.Modulo)
Parser.parseMulExpr = Parser.useGeneric(
	Parser.genericBinary,
	Parser.parseFactor,
	Token.Kind.Star,
	Token.Kind.Slash,
	Token.Kind.Modulo
)

Parser.parseSumExpr = Parser.useGeneric(Parser.genericBinary, Parser.parseMulExpr, Token.Kind.Plus, Token.Kind.Minus)
Parser.parseConcatExpr = Parser.useGeneric(Parser.genericBinary, Parser.parseSumExpr, Token.Kind.Dot2)
Parser.parseCompareExpr = Parser.useGeneric(
	Parser.genericBinary,
	Parser.parseConcatExpr,
	Token.Kind.LessThan,
	Token.Kind.LessEqual,
	Token.Kind.GreaterThan,
	Token.Kind.GreaterEqual,
	Token.Kind.EqualTo,
	Token.Kind.NotEqual
)

Parser.parseAndExpr = Parser.useGeneric(Parser.genericBinary, Parser.parseCompareExpr, Token.Kind.ReservedAnd)
Parser.parseOrExpr = Parser.useGeneric(Parser.genericBinary, Parser.parseAndExpr, Token.Kind.ReservedOr)
Parser.parseExpr = Parser.parseOrExpr

-- Note that the `if` that starts the if-else expression must be consumed prior to calling ths
-- function.
function Parser:parseIfElseExpr()
	local condition = self:parseExpr()
	self:_expect(Token.Kind.ReservedThen)

	local thenExpr = self:parseExpr()
	local elseExpr

	if self:_accept(Token.Kind.ReservedElseIf) then
		elseExpr = self:parseIfElseExpr()
	else
		self:_expect(Token.Kind.ReservedElse)
		elseExpr = self:parseExpr()
	end

	return AstNode.new(Token.Kind.IfElseExpr, condition, thenExpr, elseExpr)
end

function Parser:parseTableConstructor()
	self:_expect(Token.Kind.LeftBrace)

	local canContinue = true
	local fields = {}

	while canContinue and not self:_accept(Token.Kind.RightBrace) do
		-- [expr] = expr
		if self:_accept(Token.Kind.LeftBracket) then
			local key = self:parseExpr()
			self:_expect(Token.Kind.RightBracket)

			self:_expect(Token.Kind.Equal)
			local value = self:parseExpr()
			table.insert(fields, { key, value })
		elseif self:_peek(Token.Kind.Name) then
			-- If we see a name, it could either be the key of a value in the table, or just be a
			-- variable.
			local name = self:_accept(Token.Kind.Name)

			-- name = expr
			if self:_accept(Token.Kind.Equal) then
				local value = self:parseExpr()
				table.insert(fields, { name, value })

			-- name
			else
				table.insert(fields, name)
			end
		end

		canContinue = self:_accept(Token.Kind.Comma) or self:_accept(Token.Kind.SemiColon)
	end

	return AstNode.fromArray(AstNode.Kind.TableConstructor, fields)
end

function Parser:parseInterpolatedString()
	local strings = {}
	local exprs = {}
	local canContinue = true

	while true do
		if self:_peek(Token.Kind.InterpolatedStringBegin) or self:_peek(Token.Kind.InterpolatedStringMid) or self:_peek(Token.Kind.InterpolatedStringEnd) or self:_peek(Token.Kind.InterpolatedStringSimple) then
			canContinue = not self:_peek(Token.Kind.InterpolatedStringEnd) and not self:_peek(Token.Kind.InterpolatedStringSimple)
			
			local str = self:_accept(Token.Kind.InterpolatedStringBegin) or self:_accept(Token.Kind.InterpolatedStringMid) or self:_accept(Token.Kind.InterpolatedStringEnd) or self:_accept(Token.Kind.InterpolatedStringSimple)
			table.insert(strings, str)

			if not canContinue then
				break
			end

			if self:_peek(Token.Kind.InterpolatedStringMid) or self:_peek(Token.Kind.InterpolatedStringEnd) then
				self:_error("Maliformed interpolated string, expected expression inside '{}'")
			end

			local expr = self:parseExpr()
			table.insert(exprs, expr)
		end
	end

	return AstNode.new(AstNode.Kind.InterpolatedString, strings, exprs)
end

function Parser:parseSimpleExpr()
	-- Parser for simple tokens, where the corresponding node can be found through a table.
	local nodeKind = Parser.simpleTokens[self._token.kind]
	if nodeKind then
		self:_advance()
		return AstNode.new(nodeKind)
	end

	-- Table constructor parser.
	if self:_peek(Token.Kind.LeftBrace) then
		return self:parseTableConstructor()
	end

	-- If-else expression parser.
	if self:_accept(Token.Kind.ReservedIf) then
		return self:parseIfElseExpr()
	end

	-- String parser.
	local str = self:_accept(Token.Kind.QuotedString) or self:_accept(Token.Kind.LongString) or self:_accept(Token.Kind.InterpolatedStringSimple)
	if str then
		return AstNode.fromValue(AstNode.Kind.String, str.value)
	end

	-- Number parser.
	local number = self:_accept(Token.Kind.Number)
	if number then
		return AstNode.fromValue(AstNode.Kind.Number, number.value)
	end

	-- Interpolated string parser.
	local interBegin = self:_peek(Token.Kind.InterpolatedStringBegin)
	if interBegin then
		return self:parseInterpolatedString()
	end

	return self:parsePrimaryExpr()
end

function Parser:parsePrefixExpr()
	if self:_accept(Token.Kind.LeftParen) then
		local expr = self:parseExpr()
		self:_expect(Token.Kind.RightParen)

		return expr
	end

	return self:parseName()
end

function Parser:parseBinding()
	local name = self:parseName()
	local typeAnnotation

	if self:_accept(Token.Kind.Colon) then
		typeAnnotation = self:parseTypeAnnotation()
	end

	return AstNode.new(AstNode.Kind.Binding, name, typeAnnotation)
end

function Parser:parseExprList()
	return self:_parseList(Parser.parseExpr, Token.Kind.Comma)
end

function Parser:parseTypeList()
	return self:_parseList(Parser.parseTypeAnnotation, Token.Kind.Comma)
end

function Parser:parseBindingList(allowDot3)
	return self:_parseList(function(self)
		if allowDot3 and self:_accept(Token.Kind.Dot3) then
			local annotation
			if self:_accept(Token.Kind.Colon) then
				annotation = self:parseVariadicArgumentAnnotation()
			end

			return AstNode.new(AstNode.Kind.VarargBinding, annotation)
		end

		return self:parseBinding()
	end, Token.Kind.Comma)
end

function Parser:parseTypeParams()
	-- TODO: Implement this.
end

function Parser:parseName()
	local name = self:_expect(Token.Kind.Name)
	return AstNode.fromValue(AstNode.Kind.Name, name.value)
end

function Parser:parseTypeOrPackAnnotation()
	local type, typePack = self:parseSimpleTypeAnnotation(true)
	if typePack then
		return nil, typePack
	end
	
	return self:parseTypeAnnotation({ type })
end

function Parser:parseGenericTypeList(withDefaultValues)
	local names = {}
	local namePacks = {}

	if self:_accept(Token.Kind.LessThan) then
		local canContinue = false

		local seenDefault = false
		local seenPack = false

		while canContinue and not self:_accept(Token.Kind.GreaterThan) do
			local name = self:parseName()

			if self:_accept(Token.Kind.Dot3) and not seenPack then
				seenPack = true

				if self:shouldParseTypePackAnnotation() then
					local defaultType = self:parseTypeAnnotation()
					table.insert(names, { name, defaultType })

				elseif self:_accept(Token.Kind.LeftParen) then
					local type, typePack = self:parseTypeOrPackAnnotation()
					if type then
						self:_error("Expected type pack annotation, but got type annotation.")
					end

					table.insert(namePacks, { name, typePack })
				end
			else
				if withDefaultValues and self:_accept(Token.Kind.Equals) then
					seenDefault = true

					local defaultType = self:parseTypeAnnotation()
					table.insert(names, { name, defaultType })
				
				else
					if seenDefault then
						self:_error("Expected default type after type name")
					end

					table.insert(names, { name, nil })
				end
			end
		end
	end

	return names, namePacks
end

function Parser:parseVariadicArgumentAnnotation()
	-- Generic: a...
	if self:_peek() == Token.Kind.Name and self:_peek(2).kind == Token.Kind.Dot3 then
		local name = self:parseName()
		self:_expect(Token.Kind.Dot3)

		return AstNode.new(AstNode.Kind.VariadicTypePack, name)
	end

	-- Variadic: T
	local annotation = self:parseTypeAnnotation()
	return AstNode.new(AstNode.Kind.GenericTypePack, annotation)
end

function Parser:parseSimpleTypeAnnotation(allowPack)
	-- We should have a better system for built-in types that don't rely on the actual keywords,
	-- like `nil` and `true`.
	if self:_accept(Token.Kind.ReservedNil) then
		return AstNode.fromValue(AstNode.Kind.TypeReference, nil)
	end

	if self:_accept(Token.Kind.ReservedTrue) then
		return AstNode.fromValue(AstNode.Kind.SingletonBool, true)
	end

	if self:_accept(Token.Kind.ReservedFalse) then
		return AstNode.fromValue(AstNode.Kind.SingletonBool, false)
	end

	local stringType = self:_accept(Token.Kind.QuotedString) or self:_accept(Token.Kind.LongString)
	if stringType then
		return AstNode.fromValue(AstNode.Kind.SingletonString, stringType.value)
	end

	if self:_peek(Token.Kind.Name) then
		local name = self:parseName()
		local prefix

		-- Luau only supports one type-field indexing, not multiple.
		if self:_accept(Token.Kind.Dot) then
			prefix = name
			name = self:parseName()
		elseif self:_accept(Token.Kind.Ellipses) then
			self:_error("Unexpected '...' after type name; type pack is not allowed in this context")
		elseif name.value == "typeof" then
			self:_expect(Token.Kind.LeftParen)
			local expr = self:parseExpr()

			self:_expect(Token.Kind.RightParen)
			return AstNode.new(AstNode.Kind.TypeTypeOf, expr)
		end

		local hasParameters = false
		local parameters = {}

		-- We should rename these tokens to be something like:
		-- Token.Kind.AngleBracketLeft or something, to avoid confusion.
		if self:_peek(Token.Kind.LessThan) then
			hasParameters = true
			parameters = self:parseTypeParams()
		end

		return AstNode.new(AstNode.Kind.TypeReference, prefix, name, hasParameters, parameters)
	end

	-- Table type-annotation parser
	if self:_accept(Token.Kind.LeftBrace) then
		local canContinue = false
		local types = {}

		while canContinue and not self:_accept(Token.Kind.RightBrace) do
			-- [type]: type
			if self:_accept(Token.Kind.LeftBracket) then
				local indexType = self:parseTypeAnnotation()

				self:_expect(Token.Kind.RightBracket)
				self:_expect(Token.Kind.Colon)

				local valueType = self:parseTypeAnnotation()
				table.insert(types, AstNode.new(AstNode.Kind.TypeTableIndexer, indexType, valueType))

			-- name: type
			elseif self:_peek(Token.Kind.Name) then
				local name = self:parseName()
				table.insert(types, AstNode.new(AstNode.Kind.TypeTableProp, name, self:parseTypeAnnotation()))
			end

			canContinue = self:_accept(Token.Kind.Comma) or self:_accept(Token.Kind.SemiColon)
		end

		return AstNode.fromArray(AstNode.Kind.TypeTable, types)
	end

	-- Function type-annotation parser
	if self:_peek(Token.Kind.LessThan) or self:_peek(Token.Kind.LeftParen) then
		local generics, genericPacks = self:parseGenericTypeList()
		self:_expect(Token.Kind.LeftParen)

		local params = nil
		if self:_peek(Token.Kind.RightParen) then
			params = self:parseTypeList()
		end

		self:_expect(Token.Kind.RightParen)

		local hasReturnType = self:_accept(Token.Kind.SkinnyArrow) or self:_accept(Token.Kind.Colon)
		-- There is a chance that this is not a function at all, and is instead a type wrapped in
		-- parentheses.
		if params and #params == 1 and not hasReturnType then
			if allowPack then
				return nil, AstNode.new(AstNode.Kind.TypeList, params)
			else
				return params[0]
			end
		end

		-- Return types can also be type lists wrapped in parentheses.
		if self:_accept(Token.Kind.LeftParen) then
			local returnType = self:parseTypeList()
			self:_expect(Token.Kind.RightParen)

			return AstNode.new(AstNode.Kind.TypeFunction, generics, genericPacks, params, returnType)
		end

		return AstNode.new(AstNode.Kind.TypeFunction, generics, genericPacks, params, self:parseTypeAnnotation())
	end

	return nil
end

-- TODO: Finish this.
function Parser:parseReturnTypeAnnotation()
	local varargAnnotation = nil
	local result = {}

	-- ( type-list )
	if self:_accept(Token.Kind.LeftParen) then
		if self:_shouldParseTypePackAnnotation() then
			varargAnnotation = self:parseTypePackAnnotation()
		else
			table.insert(result, self:parseTypeAnnotation())
		end

		return AstNode.new(AstNode.Kind.TypeList, result), varargAnnotation
	end

	return nil
end

function Parser:parseOptionalReturnTypeAnnotation()
	if self:_accept(Token.Kind.Colon) or self:_accept(Token.Kind.SkinnyArrow) then
		-- TODO: Check for if the user used a skinny-arrow, and throw a deprecation warning.
		return self:parseReturnTypeAnnotation()
	end

	return nil
end

function Parser:parseTypeAnnotation(parts)
	parts = parts or { self:parseSimpleTypeAnnotation() }
	local isIntersection = false
	local isUnion = false

	while true do
		if self:_accept(Token.Kind.Pipe) then
			table.insert(parts, self:parseSimpleTypeAnnotation())
			isUnion = true

		elseif self:_accept(Token.Kind.Ampersand) then
			table.insert(parts, self:parseSimpleTypeAnnotation())
			isIntersection = true

		elseif self:_accept(Token.Kind.QuestionMark) then
			table.insert(parts, AstNode.Kind.Nil)
			isUnion = true

		else
			break
		end
	end

	if isUnion and isIntersection then
		return self:_error("Cannot combine unions and intersections")
	end

	if isUnion then
		return AstNode.fromArray(AstNode.Kind.TypeUnion, parts)
	end

	if isIntersection then
		return AstNode.fromArray(AstNode.Kind.TypeIntersection, parts)
	end

	-- If we didn't have an intersection or a union, then we can assume we only had 1 element in
	-- the array.
	return parts[1]
end

function Parser:parseTypeAlias(isExported)
	local name = self:parseName()
	local generics, genericPacks = self:parseGenericTypeList(true)

	self:_expect(Token.Kind.Equal)
	return AstNode.new(AstNode.Kind.TypeAlias, name, generics, genericPacks, self:parseTypeAnnotation(), isExported)
end

function Parser:parseFunctionArgs(selfParameter)
	local args = {}

	if self:_peek(Token.Kind.LeftBrace) then
		args = { self:parseTableConstructor() }

	elseif self:_peek(Token.Kind.QuotedString) then
		args = { self:_accept(Token.Kind.QuotedString) }

	else
		-- Since we've already checked for all other forms of providing function arguments, we can
		-- expect the user to provide normal function arguments with parentheses.
		self:_expect(Token.Kind.LeftParen)
		if not self:_accept(Token.Kind.RightParen) then
			args = self:parseExprList()
			self:_expect(Token.Kind.RightParen)
		end
	end

	if selfParameter then
		table.insert(args, 1, selfParameter)
	end

	return args
end

function Parser:parseFunctionBody()
	local generics, genericPacks = self:parseGenericTypeList(false)
	self:_expect(Token.Kind.LeftParen)

	local bindings = self:parseBindingList()
	self:_expect(Token.Kind.RightParen)

	local typeList = self:parseOptionalReturnTypeAnnotation()
	local body = self:parseBlock()

	return AstNode.new(AstNode.Kind.Function, generics, genericPacks, bindings, typeList, body)
end

function Parser:parsePrimaryExpr()
	local expr = self:parsePrefixExpr()

	while true do
		-- prefixexpr.name
		if self:_accept(Token.Kind.Dot) then
			expr = AstNode.new(AstNode.Kind.IndexName, expr, self:parseName())

		-- prefixexpr[expr]
		elseif self:_accept(Token.Kind.LeftBracket) then
			expr = AstNode.new(AstNode.Kind.IndexExpr, expr, self:parseExpr())
			self:_expect(Token.Kind.RightBracket)

		-- prefixexpr:name(functionargs)
		elseif self:_accept(Token.Kind.Colon) then
			local func = AstNode.new(AstNode.Kind.SelfIndexName, expr, self:parseName())
			expr = AstNode.new(AstNode.Kind.FunctionCall, func, self:parseFunctionArgs(expr))

		-- prefixexpr(functionargs)
		-- | prefixexpr{tableconstructor}
		-- | prefixexpr string
		elseif
			self:_peek(Token.Kind.LeftParen)
			or self:_peek(Token.Kind.LeftBrace)
			or self:_peek(Token.Kind.QuotedString)
		then
			expr = AstNode.new(AstNode.Kind.FunctionCall, expr, self:parseFunctionArgs())
		else
			break
		end
	end

	return expr
end

function Parser:parseDeclaration()
	return self:_error("Declarations are not supported yet")
end

function Parser:parseCompoundAssignment(left, oper)
	if not Parser.isExprLValue(left) then
		return self:_error("Assigned expression must be a variable or field")
	end

	local value = self:parseExpr()
	return AstNode.new(AstNode.Kind.CompoundAssign, left, oper, value)
end

function Parser:parseAssignment(left)
	if not Parser.isExprLValue(left) then
		return self:_error("Assigned expression must be a variable or field")
	end

	local values = { left }
	for _, value in ipairs(self:_parseList(Parser.parsePrimaryExpr, Token.Kind.Comma)) do
		table.insert(values, value)
	end

	return AstNode.new(AstNode.Kind.Assign, values, self:parseExprList())
end

function Parser:parseIf()
	local ifCondition = self:parseExpr()
	self:_expect(Token.Kind.ReservedThen)

	local thenBlock = self:parseBlock()
	local elseBlock = nil

	if self:_accept(Token.Kind.ReservedElseIf) then
		elseBlock = self:parseIf()
	else
		if self:_accept(Token.Kind.ReservedElse) then
			elseBlock = self:parseBlock()
		end

		-- Only expect an end if we do not have an else-if statement, in which
		-- case the nested if statement will handle the end.
		self:_expect(Token.Kind.ReservedEnd)
	end

	return AstNode.fromArray(AstNode.Kind.IfStat, ifCondition, thenBlock, elseBlock)
end

function Parser:parseStat()
	-- Do-block parser.
	if self:_accept(Token.Kind.ReservedDo) then
		local body = self:parseBlock()
		self:_expect(Token.Kind.ReservedEnd)
		return AstNode.new(AstNode.Kind.DoBlock, body)
	end

	-- While-loop parser.
	if self:_accept(Token.Kind.ReservedWhile) then
		local condition = self:parseExpr()
		self:_expect(Token.Kind.ReservedDo)

		local body = self:parseBlock()
		self:_expect(Token.Kind.ReservedEnd)

		return AstNode.new(AstNode.Kind.WhileLoop, condition, body)
	end

	-- Repeat-until loop parser.
	-- Essentially the same as the while-loop parser, except it expects a
	-- `until` instead of `do`.
	if self:_accept(Token.Kind.ReservedRepeat) then
		local condition = self:parseExpr()
		self:_expect(Token.Kind.ReservedUntil)

		local body = self:parseBlock()
		self:_expect(Token.Kind.ReservedEnd)

		return AstNode.new(AstNode.Kind.RepeatLoop, condition, body)
	end

	-- If-block parser.
	if self:_accept(Token.Kind.ReservedIf) then
		self:parseIf()
	end

	-- For-loop parser.
	if self:_accept(Token.Kind.ReservedFor) then
		local binding = self:parseBinding()

		-- Numeric for loop (doesn't have to be numeric, but yeah).
		-- for binding = expr, expr, expr do block end
		if self:_accept(Token.Kind.Equal) then
			local start = self:parseExpr()
			local finish, step

			if self:_accept(Token.Kind.Comma) then
				finish = self:parseExpr()

				if self:_accept(Token.Kind.Comma) then
					step = self:parseExpr()
				end
			end

			self:_expect(Token.Kind.ReservedDo)
			local block = self:parseBlock()

			self:_expect(Token.Kind.ReservedEnd)
			return AstNode.new(AstNode.Kind.ForLoop, binding, start, finish, step, block)

		-- For-in loop (this is what you do when you use the pairs function).
		-- for (binding)+ in (expr)+ do block end
		else
			local bindings = self:parseBindingList()

			self:_expect(Token.Kind.ReservedIn)
			local values = self:parseExprList()

			self:_expect(Token.Kind.ReservedDo)
			local block = self:parseBlock()

			self:_expect(Token.Kind.ReservedEnd)
			return AstNode.new(AstNode.Kind.ForInLoop, bindings, values, block)
		end
	end

	-- Function statement parser.
	-- name.name...name.name:name functionbody
	-- TODO: Make this, along with other statement parsers separate functions.
	if self:_accept(Token.Kind.ReservedFunction) then
		local expr = self:parseName()

		while self:_accept(Token.Kind.Dot) do
			expr = AstNode.new(AstNode.Kind.IndexName, expr, self:parseName())
		end

		if self:_accept(Token.Kind.Colon) then
			expr = AstNode.new(AstNode.Kind.SelfIndexName, expr, self:parseName())
		end

		local body = self:parseFunctionBody()
		return AstNode.new(AstNode.Kind.FunctionStat, expr, body)
	end

	if self:_accept(Token.Kind.ReservedLocal) then
		-- Local function defenition.
		if self:_accept(Token.Kind.ReservedFunction) then
			local name = self:parseName()
			local body = self:parseFunctionBody()

			self:_expect(Token.Kind.ReservedEnd)
			return AstNode.new(AstNode.Kind.LocalFunction, name, body)

		-- Local variable defenitions.
		else
			local bindings = self:parseBindingList()
			self:_expect(Token.Kind.Equal)

			local values = self:parseExprList()
			return AstNode.new(AstNode.Kind.Local, bindings, values)
		end
	end

	if self:_accept(Token.Kind.ReservedReturn) then
		local exprList = nil
		if not Parser.isFollowingBlock(self._token) and not self:_peek(Token.Kind.SemiColon) then
			self:parseExprList()
		end

		return AstNode.new(AstNode.Kind.Return, exprList)
	end

	if self:_accept(Token.Kind.ReservedBreak) then
		return AstNode.new(AstNode.Kind.Break)
	end

	local expr = self:parsePrimaryExpr()
	if expr.kind == AstNode.Kind.FunctionCall then
		return expr
	end

	if self:_peek(Token.Kind.Comma) or self:_peek(Token.Kind.Equal) then
		return self:parseAssignment(expr)
	end

	local compoundOper = Parser.compountOpers[self._token.kind]
	if compoundOper then
		return self:parseCompoundAssignment()
	end

	-- Things like `type`, `export`, and `continue` are context-dependent
	-- keywords so we handle them as if they were identifiers.
	-- TODO: Take another look at this code. Identifiers should be same thing
	-- as names.
	if expr.kind == AstNode.Kind.Name then
		-- I did not know that `type` was actually an operator until now.
		if expr.value == "type" then
			return self:parseTypeAlias(expr, false)
		elseif expr.value == "export" and self._token.kind == Token.Kind.Name and self._token.value == "type" then
			return self:parseTypeAlias(expr, true)
		end

		if expr.value == "continue" then
			return AstNode.new(AstNode.Kind.Continue)
		end

		if expr.value == "declare" then
			return self:parseDeclaration()
		end
	end

	return self:_error("Incomplete statement: expected assignment or a function call")
end

function Parser:parseBlock()
	local stats = {}
	local stat

	while not Parser.isFollowingBlock(self._token) do
		stat = self:parseStat()
		if not stat then
			break
		end

		self:_accept(Token.Kind.SemiColon)
		table.insert(stats, stat)

		if Parser.isLastStat(stat) then
			break
		end
	end

	return AstNode.fromArray(AstNode.Kind.Block, stats)
end

--[[
	Main parsing routine. Parses a chunk of luau code.
--]]
function Parser:parseChunk()
	local root = self:parseBlock()

	self:_accept(Token.Kind.EndOfFile)
	self.result = root

	return root
end

return Parser